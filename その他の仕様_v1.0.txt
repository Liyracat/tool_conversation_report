メッセージの分割ルール
・以下の条件に当てはまるspeaker行単位で分割し、それぞれを1メッセージとする。cards.speaker_idにはspeaker行に当てはまるspeaker_idを格納する。
　　・{speaker_name}
　　・{speaker_name}:

テキストの分割ルール
・改行区切り


LLMとの通信について
1. 共通の「Ollama呼び出し関数」
def call_ollama(prompt: str) -> str:
    payload = {
        "model": "gpt-oss:20b",
        "prompt": prompt,
        "stream": False,
        "options": {
            "temperature": 0,
            "num_predict": 12,
            "top_p": 0.8,
            "repeat_penalty": 1.1,
            "stop": ["\n\n"]
        }
    }
    r = requests.post("http://localhost:11434/api/generate", json=payload, timeout=120)
    r.raise_for_status()
    return r.json()["response"].strip()
ここは一切分岐させない。
ロール付与でも関連付けでも同じ。

2. ロール付与用プロンプト生成
def build_role_prompt(contents: str) -> str:
    return f"""あなたは分類器です。出力は2行のみ。
1行目：許可単語一覧から1つを完全一致で出力。
2行目：自信度を0.00〜1.00で出力。
他の文章は禁止。

許可単語一覧：
{card_roles_name( / 区切りで全件表示)}

contents：
{contents}
"""
→ 今まさに 正常動作を確認できている形。これが基準。

3. 関連付け用プロンプト生成（同じ思想）
def build_link_prompt(from_text: str, to_text: str) -> str:
    return f"""あなたは関係分類器です。出力は2行のみ。
1行目：許可単語一覧から1つを完全一致で出力。関係が無ければ「none」。
2行目：自信度を0.00〜1.00で出力。
他の文章は禁止。

許可単語一覧：
{link_kinds_name( / 区切りで全件表示)}

from：
{from_text}

to：
{to_text}
"""

4. LLMからの返り値に対する処理
・card_roles_name → 最初に各値に該当する値を検索し、cards.card_role_idに登録する
・link_kind_name → 最初に各値に該当する値を検索し、link_suggestions.suggested_link_kind_idに登録する
・confidence → 数値をすべて取得し、最小値の値をcards.card_role_confidence または link_suggestions.suggested_confidenceに格納する